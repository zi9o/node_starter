const BASE_MESSAGES = {
  any: {
    unknown: "{{#label}} n'est pas autorisé(e)",
    invalid: "{{#label}} contient une valeur invalide",
    empty: "{{#label}} ne doit pas être vide",
    required: "{{#label}} est requis",
    allowOnly: "{{#label}} doit prendre l'une des valeurs suivantes: {{#valids}}",
    default: "{{#label}} génère une erreur quand on lance la valeur par défaut",
  },
  alternatives: {
    base: "{{#label}} ne correspondant à aucune des alternatives autorisées",
  },
  array: {
    base: "{{#label}} doit être un tableau",
    includes: "{{#label}} à la position {{#pos}} ne correspond à aucun des types autorisés",
    includesSingle: "{{#label}} l'une des valeurs de \"{{!label}}\" ne correspond à aucun des types autorisés",
    includesOne: "{{#label}} à la position {{#pos}} échoue parce que {{#reason}}",
    includesOneSingle: "{{#label}} l'une des valeurs de \"{{!label}}\" échoue parce que {{#reason}}",
    includesRequiredUnknowns: "{{#label}} ne contient pas {{#unknownMisses}} valeur(s) requise(s)",
    includesRequiredKnowns: "{{#label}} ne contient pas {{#knownMisses}}",
    includesRequiredBoth: "{{#label}} ne contient pas {{#knownMisses}} et {{#unknownMisses}} autre(s) valeur(s) requise(s)",
    excludes: "{{#label}} à la position {{#pos}} contient une valeur exclue",
    excludesSingle: "{{#label}} l'une des valeurs de \"{{!label}}\" contient une valeur exclue",
    min: "{{#label}} doit contenir au moins {{#limit}} valeur(s)",
    max: "{{#label}} doit contenir moins que ou égal à {{#limit}} articles",
    length: "{{#label}} doit contenir {{#limit}} articles",
    ordered: "{{#label}} à la position {{#pos}} échoue parce que {{#reason}}",
    orderedLength: "{{#label}} à la position {{#pos}} échoue parce que le tableau doit contenir au maximum {{#limit}} articles",
    ref: "{{#label}} références \"{{#ref}}\" qui n'est pas un nombre entier positif",
    sparse: "{{#label}} ne doit pas être un tableau épars",
    unique: "{{#label}} la position {{#pos}} contient une valeur en double",
  },
  boolean: {
    base: "{{#label}} doit être booléen",
  },
  binary: {
    base: "{{#label}} doit être un tampon ou une chaîne de caractères",
    min: "{{#label}} doit contenir au moins {{#limit}} octets",
    max: "{{#label}} doit contenir au maximum {{#limit}} octets",
    length: "{{#label}} doit contenir {{#limit}} octets",
  },
  date: {
    base: "{{#label}} doit être un nombre de millisecondes ou une date valide",
    format: "{{#label}} doit être une chaîne avec l'un des formats suivants {{#format}}",
    strict: "{{#label}} doit être une date de validité",
    min: "{{#label}} doit être égal(e) à au moins \"{{#limit}}\"",
    max: "{{#label}} doit être égal(e) au maximum à \"{{#limit}}\"",
    isoDate: "{{#label}} doit être une date ISO 8601 valide",
    timestamp: {
      javascript: "{{#label}} doit être valable ou nombre de millisecondes",
      unix: "{{#label}} doit être une date valide ou le nombre de secondes",
    },
    ref: "{{#label}} références \"{{#ref}}\" doit être une date",
  },
  function: {
    base: "{{#label}} doit être une fonction",
    arity: "{{#label}} doit avoir une solidarité de {{#n}}",
    minArity: "{{#label}} doit avoir une solidarité supérieure ou égale à {{#n}}",
    maxArity: "{{#label}} doit avoir une solidarité moindre ou égale à {{#n}}",
    ref: "{{#label}} référence doit être de type Joi",
    class: "{{#label}} doit être une classe",
  },
  lazy: {
    base: "{{#label}} erreur: schéma doit être de type lazy",
    schema: "{{#label}} erreur: les fonctions schéma doivent retourner un type lazy",
  },
  object: {
    base: "{{#label}} doit être un objet",
    child: "{{#label}} le sous-objet \"{{!label}}\" échoue parce que {{#reason}}",
    min: "{{#label}} doit contenir au moins {{#limit}} sous-objets",
    max: "{{#label}} doit contenir au maximum {{#limit}} sous-objets",
    length: "{{#label}} doit contenir {{#limit}} sous-objets",
    allowUnknown: "{{#label}} n'est pas autorisé(e)",
    with: "{{#label}} \"{{#mainWithLabel}}\" pair requis manquant : \"{{#peerWithLabel}}\" ",
    without: "{{#label}} \"{{#mainWithLabel}}\" conflit avec un pair interdit \"{{#peerWithLabel}}\"",
    missing: "{{#label}} doit contenir au moins un des éléments suivants {{#peersWithLabels}}",
    xor: "{{#label}} contient un conflit entre les pairs exclusifs {{#peersWithLabels}}",
    or: "{{#label}} doit contenir au moins un des éléments suivants {{#peersWithLabels}}",
    and: "{{#label}} contient {{#presentWithLabels}} sans ses pairs obligatoires {{#missingWithLabels}}",
    nand: "{{#label}} \"{{#mainWithLabel}}\" ne doit pas exister simultanément avec {{#peersWithLabels}}",
    assert: "{{#label}} la validation de \"{{#ref}}\" a échoué parce que  \"{{#ref}}\" échoue de {{#message}}",
    rename: {
      // eslint-disable-next-line max-len
      multiple: "{{#label}} ne peut pas renommer le sous-objet \"{{#from}}\" parce que plusieurs renoms sont désactivés et qu'une autre clé a déjà été renommée en \"{{#to}}\"",
      // eslint-disable-next-line max-len
      override: "{{#label}} ne peut pas renommer le sous-objet \"{{#from}}\" parce que le contournement est désactivé et la cible \"{{#to}}\" est désactivée",
      regex: {
        // eslint-disable-next-line max-len
        multiple: "{{#label}} ne peut pas renommer le sous-objet \"{{#from}}\" parce que plusieurs renoms sont désactivés et qu'une autre clé a déjà été renommée en \"{{#to}}\"",
        // eslint-disable-next-line max-len
        override: "{{#label}} ne peut pas renommer le sous-objet \"{{#from}}\" parce que le contournement est désactivé et la cible \"{{#to}}\" est désactivée",
      },
    },
    type: "{{#label}} doit être une instance de \"{{#type}}\"",
    schema: "{{#label}} doit être une instance de Joi",
  },
  number: {
    base: "{{#label}} doit être un nombre",
    min: "{{#label}} doit être au moins égal(e) à {{#limit}}",
    max: "{{#label}} doit être au maximum égal(e) à {{#limit}}",
    less: "{{#label}} doit être inférieur(e) à {{#limit}}",
    greater: "{{#label}} doit être supérieur(e) à {{#limit}}",
    float: "{{#label}} doit être un nombre en virgule flottante",
    integer: "{{#label}} doit être un entier",
    negative: "{{#label}} doit être un nombre négatif",
    positive: "{{#label}} doit être un nombre positif",
    precision: "{{#label}} ne doit pas avoir plus de {{#limit}} précision décimale",
    ref: "{{#label}} référence \"{{#ref}}\" qui n'est pas un nombre",
    multiple: "{{#label}} doit être un multiple de {{#multiple}}",
    port: "{{#label}} doit être un port valide",
    map: "{{#label}} doit être un nombre ou un de {{#enums}}",
  },
  string: {
    base: "{{#label}} doit être une chaîne de caractères",
    min: "{{#label}} la longeur doit être au moins égal(e) à {{#limit}}",
    max: "{{#label}} la longeur doit être au maximum égal(e) à {{#limit}}",
    length: "{{#label}} la longeur doit être égal(e) à {{#limit}}",
    alphanum: "{{#label}} ne doit contenir que des caractères alphanumériques",
    token: "{{#label}} ne doit contenir que des caractères alphanumériques et soulignés",
    regex: {
      base: "{{#label}} avec la valeur \"{{#value}}\" ne correspond pas au modèle suivant demandé: {{#regex}}",
      name: "{{#label}} avec la valeur \"{{#value}}\" ne correspond pas à la valeur du modèle {{#name}}",
      invert: {
        base: "{{#label}} avec la valeur \"{{#value}}\" ne correspond pas au modèle suivant demandé: {{#regex}}",
        name: "{{#label}} avec la valeur \"{{#value}}\" ne correspond pas à la valeur du modèle {{#name}}",
      },
    },
    email: "{{#label}} doit être un courriel valide",
    uri: "{{#label}} doit être un URI valide",
    uriRelativeOnly: "{{#label}} doit être un parent uri",
    uriCustomScheme: "{{#label}} doit être un uri valide avec un schéma correspondant au modèle {{#scheme}}",
    isoDate: "{{#label}} doit être une date ISO 8601 valide",
    guid: "{{#label}} doit être un GUID valide",
    hex: "{{#label}} ne doit contenir que des caractères hexadécimaux",
    hexAlign: "{{#label}} hex décodé représentation doit être octet aligné",
    base64: "{{#label}} doit être de type base64.",
    hostname: "{{#label}} doit être un nom de domaine valide",
    normalize: "{{#label}} doit être unicode normalisé en la {{#form}} forme",
    lowercase: "{{#label}} doivent contenir uniquement des caractères minuscules",
    uppercase: "{{#label}} ne doivent contenir que des caractères majuscules",
    trim: "{{#label}} ne doit pas avoir d'espaces au début ou à la fin",
    creditCard: "{{#label}} doit être une carte de crédit",
    ref: "{{#label}} référence \"{{#ref}}\" doit être numérique",
    ip: "{{#label}} doit être une adresse IP valide avec un CIDR {{#cidr}}",
    ipVersion: "{{#label}} doit être une adresse IP valide d'une des versions suivantes {{#version}} avec un CIDR {{#cidr}}",
    password: "Le mot de passe doît contenir un chiffre, une majuscule, une minuscule et un caractère spécial.",
  },
};

module.exports = {BASE_MESSAGES};
